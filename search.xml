<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>phpStudy默认配置致Nginx解析漏洞复现</title>
      <link href="2021/03/23/phpStudy%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E8%87%B4Nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>2021/03/23/phpStudy%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E8%87%B4Nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="phpStudy默认配置致Nginx解析漏洞复现"><a href="#phpStudy默认配置致Nginx解析漏洞复现" class="headerlink" title="phpStudy默认配置致Nginx解析漏洞复现"></a>phpStudy默认配置致Nginx解析漏洞复现</h1><ul><li><p>phpStudy介绍</p><blockquote><p>phpStudy是一个PHP调试环境的程序集成包，兼容Windows和Linux系统，支持Web端管理，可以一键创建网站、FTP、数据库等，实现了文件管理，PHP多版本共存及切换等功能.</p><p>该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer，一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境.</p></blockquote></li><li><p>环境配置</p><blockquote><p>影响版本:   phpStudy &lt;=8.1.0.7 for Windows</p><p>nginx全版本都存在解析漏洞</p></blockquote></li><li><p>漏洞概述</p><blockquote><p>该漏洞是Nginx的解析漏洞，由于phpstudy中配置文件的不当，造成了/xx.php解析漏洞，故此将文件解析为php运行。</p></blockquote></li><li><p>环境搭建</p><blockquote><p>Nginx  :1.15.11</p><p>phpstudy :8.0.7</p><p>下载好phpstudy后。启动:</p><p><img src="D:\hexo\mybolg2\source\img\phpstudy.png"></p><p>将图片马2.jpg放到web根目录下，</p><blockquote><p>制造图片马的方法:</p><ul><li><p>命令行</p><p>准备两个文件，</p><p>![](D:\hexo\mybolg2\source\img\屏幕截图 2021-03-23 172339.png)</p><p>一张图片和一个内容为<code>&lt;?php phpinfo();?&gt;</code>写好的php文件 2.php.</p><p>将二者放到同一个目录下，进入该目录执行cmd命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy 2.jpg&#x2F;b + 2.php&#x2F;a 3.jpg  </span><br></pre></td></tr></table></figure><p>![](D:\hexo\mybolg2\source\img\屏幕截图 2021-03-23 172957.png)</p><p>发现成功插入。</p></li></ul></blockquote><ul><li>访问该图片马</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;http:&#x2F;&#x2F;127.0.0.1&#x2F;3.jpg</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>![](D:\hexo\mybolg2\source\img\屏幕截图 2021-03-23 173528.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;http:&#x2F;&#x2F;127.0.0.1&#x2F;3.jpg&#x2F;.php</span><br></pre></td></tr></table></figure><p><img src="D:\hexo\mybolg2\source\img\QQ截图20210323173840.png"></p><p>发现图片马已将成功当成php文件执行了。</p></blockquote></blockquote></li><li><p>漏洞原理</p><p><img src="D:\hexo\mybolg2\source\img\QQ截图20210323174839.jpg"></p><blockquote><p>这个配置的开启是导致这个漏洞的根本原因。</p><p>Nginx的解析漏洞的出现和Nginx的版本没有关系，漏洞的产生是由于php配置问题导致的。但在高版本的php中，由于“security.limit_extensions”的引入，使得该漏洞难以被成功利用。</p><p>nginx本身并不能处理php文件，它遇见php文件时会交给FastCGI 管理器，交给php解析器进行处理。</p><p>在 vhosts 文件夹下 localhost.conf</p><p><img src="D:\hexo\mybolg2\source\img\QQ截图20210323180006.jpg"></p><p>当你输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;3.jpg&#x2F;.php</span><br></pre></td></tr></table></figure><p>$fastcgi_script_name会被设置为3.jpg/.php，然后构造成SCRIPT_FILENAME传递给PHP CGI.</p><blockquote><p>配置文件php.ini中存在参数cgi.fix_pathinfo，默认值为1，主要用于修复路径，若当前路径不存在则会解析上层路径的文件。</p></blockquote><p>因此如果构造访问地址为<code>http://127.0.0.1/3.jpg/.php</code>（其中3.jpg是上传的包含php代码的图片文件，x.php可以是服务器中任意一个不存在的php文件），则会导致fastcgi处理的文件就变成/1.jpg。</p><blockquote><p>同时，配置文件php-fpm.conf中的security.limit_extensions参数值为空，没有限制fastcgi的解析类型，即任意后缀名的文件都会当成php文件进行解析执行。</p></blockquote></blockquote></li><li><p>漏洞修复</p><blockquote><p>在高版本的nginx引入了security.limit_extensions，修改他的值可以让入侵者难以利用nfinx解析漏洞。</p><blockquote><p>security.limit_extensions:   它定义了本来是只把php文件传给php解释器处理，现在还可以把其它的一些类型的文件传输给php解释器。</p></blockquote><ul><li>php.ini 中 fix_pathinfo 禁用为0</li></ul><blockquote><p>cgi.fix_pathinfo=0</p></blockquote><ul><li>Nginx.conf添加如下代码</li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php(.*)$ &#123;</span><br><span class="line">      if ( $fastcgi_script_name ~ \..*\&#x2F;.*php )&#123;</span><br><span class="line">        return 403;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>绕过CDN查找ip</title>
      <link href="2021/03/20/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BEip/"/>
      <url>2021/03/20/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BEip/</url>
      
        <content type="html"><![CDATA[<h1 id="绕过CDN的几种方法"><a href="#绕过CDN的几种方法" class="headerlink" title="绕过CDN的几种方法"></a>绕过CDN的几种方法</h1><ul><li><p>查询子域名的ip</p><blockquote><p>毕竟 CDN 还是不便宜的，所以很多站长可能只会对主站或者流量大的子站点做了 CDN，而很多小站子站点又跟主站在同一台服务器或者同一个C段内，此时就可以通过查询子域名对应的 IP 来辅助查找网站的真实IP</p></blockquote></li><li><p>查询主域名</p><blockquote><p>以前用CDN的时候有个习惯，只让WWW域名使用cdn，秃域名不适用，为的是在维护网站时更方便，不用等cdn缓存。所以试着把目标网站的www去掉，ping一下看ip是不是变了，您别说，这个方法还真是屡用不爽</p></blockquote></li><li><p>邮件服务器</p><blockquote><p>一般的邮件系统都在内部，没有经过CDN的解析，通过目标网站用户注册或者RSS订阅功能，查看邮件，寻找邮件头中的邮件服务器域名IP，ping这个邮件服务器的域名，就可以获得目标的真实IP(必须是目标自己的邮件服务器，第三方或者公共邮件服务器是没有用的)。</p></blockquote></li><li><p>查看域名历史解析记录</p><blockquote><p>也许目标很久之前没有使用CDN，所以可能会存在使用 CDN 前的记录。</p><ol><li>iphistory：<a href="https://viewdns.info/iphistory/">https://viewdns.info/iphistory/</a> </li><li>DNS查询：（<a href="https://dnsdb.io/zh-cn/%EF%BC%89">https://dnsdb.io/zh-cn/）</a> </li><li>微步在线：（<a href="https://x.threatbook.cn/%EF%BC%89">https://x.threatbook.cn/）</a> </li><li>域名查询：（<a href="https://site.ip138.com/%EF%BC%89">https://site.ip138.com/）</a> </li><li>DNS历史查询：（<a href="https://securitytrails.com/%EF%BC%89">https://securitytrails.com/）</a> </li><li>Netcraft：<a href="https://sitereport.netcraft.com/?url=github.com">https://sitereport.netcraft.com/?url=github.com</a> </li></ol></blockquote></li><li><p>国外访问</p><blockquote><p>国内的CDN往往只对国内用户的访问加速，而国外的CDN就不一定了。因此，通过国外在线代理网站访问 ，可能会得到真实的ip地址。</p><p><a href="https://asm.ca.com/zh_cn/ping.php">https://asm.ca.com/zh_cn/ping.php</a></p><p><a href="http://host-tracker.com/">http://host-tracker.com/</a></p><p><a href="http://www.webpagetest.org/">http://www.webpagetest.org/</a></p><p><a href="https://dnscheck.pingdom.com/">https://dnscheck.pingdom.com/</a></p></blockquote></li><li><p>Nslookup查询</p><blockquote><p><a href="https://blog.csdn.net/qq_36119192/article/details/82752515#%E5%90%84%E7%A7%8D%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95">各种解析记录</a></p><p>查询域名的NS记录、MX记录、TXT记录等很有可能指向的是真实ip或同C段服务器</p></blockquote></li><li><p>利用SSL证书寻找真实IP</p><blockquote><p>证书颁发机构(CA)必须将他们发布的每个SSL/TLS证书发布到公共日志中，SSL/TLS证书通常包含域名、子域名和电子邮件地址。因此SSL/TLS证书成为了攻击者的切入点。</p><p>SSL证书搜索引擎：</p><p><a href="https://censys.io/ipv4?q=github.com">https://censys.io/ipv4?q=github.com</a> Censys 证书搜索</p></blockquote></li></ul><p>参考链接:</p><p><a href="https://netsecurity.51cto.com/art/202008/624770.htm">https://netsecurity.51cto.com/art/202008/624770.htm</a></p><p><a href="https://blog.csdn.net/qq_36119192/article/details/89151336">https://blog.csdn.net/qq_36119192/article/details/89151336</a></p><p><a href="https://blog.csdn.net/qq_36119192/article/details/82752515#%E5%90%84%E7%A7%8D%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95">https://blog.csdn.net/qq_36119192/article/details/82752515#%E5%90%84%E7%A7%8D%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>信息收集</title>
      <link href="2021/03/20/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>2021/03/20/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>在渗透与测试工作中，首先进行的应该就是信息收集，</p><p>一是全面统计资产，</p><p>二就是知己知彼方能百战不殆。</p><p>信息收集的完成度直接关系到我们入侵的成功率，渗透测试中有一门学问叫社会工程学，社工就是和信息收集有关。</p></blockquote><h2 id="针对一个渗透目标的信息收集"><a href="#针对一个渗透目标的信息收集" class="headerlink" title="针对一个渗透目标的信息收集"></a>针对一个渗透目标的信息收集</h2><ul><li><p>收集ip信息</p><blockquote><p>当你有了一个渗透目标，先不要急于去攻击它，找一下它的ip是否是真实ip,  因为现在很多网站为了在全国各地访问的流畅性，通常都做了CDN加速，很可能你ping到的ip不是真实的ip。</p><blockquote><p>怎么验证是否是真实ip呢?</p><p><a href="http://ping.chinaz.com/">多地ping</a>  服务查看多地ping的地点ip是否一致，如果一致，可能就是，真实ip,如果不一致那就是存在CND加速。</p><p>怎样通过CDN加速找到真实ip呢?</p><p>见我的另一篇  <a href="%E7%BB%95%E8%BF%87cdn%E6%9F%A5%E6%89%BEip.md">绕过cdn的几种方法</a></p></blockquote></blockquote></li><li><p>网站使用的框架，中间件。</p><blockquote><p><a href="http://whatweb.bugscaner.com/look/">whatweb</a></p><p><a href="http://whois.chinaz.com/">whois</a></p><p>whois信息可以获取关键注册人的信息，包括注册商、联系人、联系邮箱、联系电话、创建时间等,可以进行邮箱反查域名，爆破邮箱，社工，域名劫持，寻找旁站等等。</p><p>谷歌插件-wappalyzer,也能收集到很多有用的信息</p><p><a href="https://www.aizhan.com/">爱站</a></p></blockquote></li><li><p>目标敏感信息</p><blockquote><p>当确定了公司后，我们可以去互联网上查询与该公司有关的任何信息。比如，公司的邮箱格式，公司的员工姓名，以及与该公司有关的任何信息。并且，我们还可以去Github、码云等代码托管平台上查找与此有关的敏感信息，有些粗心的程序员在将代码上传至代码托管平台后，并没有对代码进行脱敏处理。导致上传的代码中有包含如数据库连接信息、邮箱密码、还有可能有泄露的源代码等。<br><a href="https://blog.csdn.net/qq_36119192/article/details/99690742">github搜索</a> </p></blockquote></li><li><p>网站指纹识别</p><blockquote><p>在渗透测试中，对目标服务器进行指纹识别是相当有必要的，因为只有识别出相应的Web容器或者CMS，才能查找与其相关的漏洞，然后才能进行相应的渗透操作。CMS又称整站系统。常见的CMS有：WordPress、Dedecms、Discuz、PhpWeb、PhpWind、Dvbbs、PhpCMS、ECShop、、SiteWeaver、AspCMS、帝国、Z-Blog等。</p><p>常见的网站指纹识别工具有：御剑 等。</p><p>在线指纹识别网站：</p><p>BugScaner：<a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a><br>云悉指纹：<a href="http://www.yunsee.cn/finger.html">http://www.yunsee.cn/finger.html</a><br>WhatWeb：<a href="https://whatweb.net/">https://whatweb.net/</a></p></blockquote></li><li><p>服务器类型</p><blockquote><p>服务器信息包括服务器用的操作系统：Linux 还是 Windows 。现在企业网站服务器的操作系统有百分之九十以上用的是Linux操作系统。知道了服务器的操作系统之后，还需要知道操作系统使用的具体版本。因为很多低版本的操作系统都存在已知的漏洞。</p><p>判断是Linux还是Windows最简单就是通过ping来探测，Windows的TTL值都是一般是128，Linux则是64。所以大于100的肯定是Windows，而几十的肯定是Linux。但是，通过TTL值来判断服务器类型也不是百分之百准确的，有些windows服务器的TTL值也是几十，而且有的服务器禁止ping。</p><p>而判断目标网站服务器的具体的版本的话，可以采用 nmap 进行扫描， -O 和 -A 参数都能扫描出来</p><p>分享个小技巧:</p><p>域名后面加上index.html  然后和加上inDex.html作对比。</p><p>因为windows对大小写不敏感而linux对大小写敏感，如果一样的话应该是windows，如果不一样的话应该是linux.</p></blockquote></li><li><p>网站容器(Apache/Nginx/Tomcat/IIS)</p><blockquote><p>知道了这些信息之后，我们就需要知道网站用的web服务器是什么类型的：Apache、Nginx、Tomcat 还是 IIS。知道了web服务器是哪种类型后，我们还要探测web服务器具体的版本。比如Ngnix版本&lt;0.83会有解析漏洞 ，IIS6.0会有文件名解析漏洞、IIS7.0会有畸形解析漏洞等。不同的web服务器版本，存在着不同漏洞。</p></blockquote></li><li><p>脚本类型(php/jsp/asp/aspx)</p><blockquote><p>我们需要知道网站用的脚本类型：php 、Jsp 、Asp 、Aspx 。</p><p>1：可以根据网站URL来判断</p><ol start="2"><li>谷歌插件-wappalyzer,</li></ol></blockquote></li><li><p>数据库类型(Mysql/Oracle/Accees/Mqlserver)</p><blockquote><p>我们需要知道网站用的是哪种类型的数据库：Mysql、Oracle、SqlServer 还是 Access 。虽然这几种数据库的语法大体上相同，但是还是有区别的。所以我们还是要知道目标网站用的是哪种数据库，并且数据库是哪个版本的.</p><p>几种数据库的区别：</p><p>Access 全名是Microsoft Office Access，是由微软发布的关联式数据库管理系统。小型数据库，当数据库达到100M左右的时候性能就会下降。数据库后缀名： .mdb   一般是asp的网页文件用access数据库<br>SQL Server是由Microsoft开发和推广的关系数据库管理系统（DBMS），是一个比较大型的数据库。端口号为1433。数据库后缀名 .mdf<br>MySQL 是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL是最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的应用软件之一，MySQL数据库大部分是php的页面。默认端口是3306<br>Oracle又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。常用于比较大的网站。默认端口是1521<br>首先，成本上的差距，access是不要钱的，mysql也是开源的，sql server 是收费的一般也就几千，Oracle的费用则数万。其次，处理能力，access支持千以内的访问量，sql server支持几千到上万的访问，而Oracle则支持海量的访 问。再次，从数据库的规模来看，access是小型数据库，，mysql 是中小型数据库，sql server是中型数据库，Oracle是大型数据库。</p><p>常见搭配：</p><p>ASP 和 ASPX：ACCESS、SQL Server<br>PHP：MySQL、PostgreSQL</p><p>JSP：Oracle、MySQL</p></blockquote></li><li><p>网站资产收集</p><blockquote><ul><li>子域名收集</li></ul><blockquote><p>在线子域名收集;</p><p><a href="https://ip138.com/">https://ip138.com/</a></p><p><a href="https://www.aizhan.com/cha/">https://www.aizhan.com/cha/</a></p><p><a href="http://tools.bugscaner.com/subdomain/?domain=www.aizhan.com">http://tools.bugscaner.com/subdomain/?domain=www.aizhan.com</a></p><p>使用google hack 语法也可。</p><p>工具类；</p><p>子域名挖掘机;</p></blockquote><p>+ </p></blockquote></li><li><p>主机端口扫描</p><blockquote><p>需要知道目标服务器开放了哪些端口，常见的如 135 、137 、138 、139 、445，这几个端口经常爆发漏洞。以下是一些服务端口的漏洞：</p><ul><li>22——&gt;ssh弱口令</li><li>873——&gt;rsync 未授权访问漏洞</li><li>3306——&gt;mysql弱口令</li><li>6379——&gt;redis未授权访问漏洞</li></ul></blockquote></li><li><p>网站敏感目录和文件</p><blockquote><p>扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏</p><p>后台目录：弱口令，万能密码，爆破<br>安装包：获取数据库信息，甚至是网站源码<br>上传目录：截断、上传图片马等<br>mysql管理接口：弱口令、爆破，万能密码，然后脱裤，甚至是拿到shell<br>安装页面 ：可以二次安装进而绕过<br>phpinfo：会把你配置的各种信息暴露出来<br>编辑器：fck、ke、等<br>iis短文件利用：条件比较苛刻  windows、apache等<br>提到了网站敏感目录我们就不得不提 robots.txt 文件了.</p><p>robots.txt 文件是专门针对搜索引擎机器人robot 编写的一个纯文本文件。我们可以在这个文件中指定网站中不想被robot访问的目录。这样，我们网站的部分或全部内容就可以不被搜索引擎收录了，或者让搜索引擎只收录指定的内容。因此我们可<br>以利用robots.txt让Google的机器人访问不了我们网站上的重要文件，GoogleHack的威胁也就不存在了.</p><p>虽然robots文件目的是让搜索蜘蛛不爬取想要保护的页面，但是如果我们知道了robots文件的内容的话，我们就可以知道目标网站哪些文件夹不让访问，从侧面说明这些文件夹是很重要的了。</p><p>扫描后台目录的工具: 御剑 </p><p><strong>使用中国菜刀可以把网站的目录结构爬下来进行分析。</strong></p></blockquote></li><li><p>旁站和c段扫描</p><blockquote><p>旁站指的是同一服务器上的其他网站，很多时候，有些网站可能不是那么容易入侵。那么，可以查看该网站所在的服务器上是否还有其他网站。如果有其他网站的话，可以先拿下其他网站的webshell，然后再提权拿到服务器的权限，最后就自然可以拿下该网站了！</p><p>对于红蓝对抗和护网，C段扫描比较有意义。对于单独网站的渗透测试，C段扫描意义不大。C段指的是同一内网段内的其他服务器，每个IP有ABCD四个段，举个例子，192.168.0.1，A段就是192，B段是168，C段是0，D段是1，而C段嗅探的意思就是拿下它同一C段中的其中一台服务器，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务器。</p><p>旁站和C段在线查询地址：</p><ul><li><a href="http://www.webscan.cc/">http://www.webscan.cc/</a></li></ul></blockquote></li><li><p>网站漏洞扫描</p><blockquote><p>网站漏洞扫描就是直接对网站进行漏洞探测了。网站漏洞扫描也有很多工具。比如 AWVS、AppScan、OWASP-ZAP、nessuss等等。但是需要注意的是，使用漏扫工具直接对网站进行扫描，因为一下子流量过大，有些网站可能会崩溃。所以一般最好不要使用漏洞扫描工具对网站进行扫描。并且如果未经授权就用漏扫对网站进行扫描还是违法的！</p></blockquote><p><a href="https://mp.weixin.qq.com/s/XRulzmBQbV59nsDpTvmJ2Q">推荐文章</a></p></li></ul><p><a href="https://mp.weixin.qq.com/s/XRulzmBQbV59nsDpTvmJ2Q">https://mp.weixin.qq.com/s/XRulzmBQbV59nsDpTvmJ2Q</a></p>]]></content>
      
      
      <categories>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一次补天专属src漏洞挖掘</title>
      <link href="2021/03/19/%E4%B8%80%E6%AC%A1%E8%A1%A5%E5%A4%A9%E4%B8%93%E5%B1%9Esrc%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
      <url>2021/03/19/%E4%B8%80%E6%AC%A1%E8%A1%A5%E5%A4%A9%E4%B8%93%E5%B1%9Esrc%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一次补天专属src漏洞挖掘"><a href="#一次补天专属src漏洞挖掘" class="headerlink" title="一次补天专属src漏洞挖掘"></a>一次补天专属src漏洞挖掘</h1><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><blockquote><p>目标:<a href="https://www.sdada.edu.cn/">https://www.sdada.edu.cn/</a></p></blockquote><ul><li><p>查找ip</p><blockquote><p><a href="http://ping.chinaz.com/">多地ping</a></p><p>使用多地ping网站进行cdn测试，发现该网站多地ping的ip一样，不存在CDN加速。、</p><p>124.128.249.249 是它的ip</p></blockquote></li></ul><blockquote><p>JavaScript Frameworks:<strong>jQuery</strong></p><p>JavaScript Libraries:<strong>Slick</strong></p><p>Server: VWebServer</p><p>nginx: Web</p></blockquote><ul><li><p>子域名</p><blockquote><table><thead><tr><th align="left">0</th><th align="center">19.sdada.edu.cn</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">anxinfu.sdada.edu.cn</td></tr><tr><td align="left">2</td><td align="center">art.sdada.edu.cn</td></tr><tr><td align="left">3</td><td align="center">bwcxljsm.sdada.edu.cn</td></tr><tr><td align="left">4</td><td align="center">hum.sdada.edu.cn</td></tr><tr><td align="left">5</td><td align="center">ids.sdada.edu.cn</td></tr><tr><td align="left">6</td><td align="center">jy.sdada.edu.cn</td></tr><tr><td align="left">7</td><td align="center">live.sdada.edu.cn</td></tr><tr><td align="left">8</td><td align="center">m.sdada.edu.cn</td></tr><tr><td align="left">9</td><td align="center">mda.sdada.edu.cn</td></tr><tr><td align="left">10</td><td align="center">sdada.edu.cn</td></tr><tr><td align="left"></td><td align="center"></td></tr><tr><td align="left">12</td><td align="center">upload.sdada.edu.cn</td></tr><tr><td align="left">13</td><td align="center">wap.sdada.edu.cn</td></tr><tr><td align="left">14</td><td align="center"><a href="http://www.sdada.edu.cn/">www.sdada.edu.cn</a></td></tr><tr><td align="left">15</td><td align="center">xcb.sdada.edu.cn</td></tr><tr><td align="left">16</td><td align="center">xxfy.sdada.edu.cn</td></tr><tr><td align="left">17</td><td align="center">zs.sdada.edu.cn</td></tr></tbody></table></blockquote><blockquote><p><a href="https://chaziyu.com/sdada.edu.cn/">更多子域名</a></p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>google语法</title>
      <link href="2021/03/19/google%E8%AF%AD%E6%B3%95/"/>
      <url>2021/03/19/google%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="google语法"><a href="#google语法" class="headerlink" title="google语法"></a>google语法</h1><h2 id="google语法简介"><a href="#google语法简介" class="headerlink" title="google语法简介"></a>google语法简介</h2><blockquote><p>Google是一款十分强大的搜索引擎，黑客们常常借助它搜索网站的一些敏感目录和文件，甚至可以利用它的搜索功能来自动攻击那些有漏洞的网站；我们在日常的生活中正确的借助Google搜索也可以更加高效的找到我们需要的东西。</p></blockquote><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><blockquote><p>AND  | OR</p><p>site：可以限制你搜索范围的域名.</p><p>例如 :   <code> site :edu.cn</code></p><p>inurl：用于搜索管理登录入口、注入点、指点站点,搜索返回的页面中的url含有搜索的关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;inurl: php?id&#x3D;1</span><br></pre></td></tr></table></figure><p>intext: 只搜索网页<body>部分中包含的文字(也就是忽略了标题、URL等的文字)</p><p>intitle: 查包含关键词的页面，一般用于社工别人的webshell密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;intitle:后台管理 inurl:admin        #可以与inurl结合使用提高搜索精度</span><br></pre></td></tr></table></figure><p>filetype：搜索文件的后缀或者扩展名</p><p>intitle：搜索网页中的标题内容与关键字匹配的页面</p><p>link: 可以得到一个所有包含了某个指定URL的页面列表.</p></blockquote><h1 id="一些实例"><a href="#一些实例" class="headerlink" title="一些实例"></a>一些实例</h1><blockquote><p>查找后台地址：site:域名 inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cms</p><p>查找文本内容：site:域名 intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号|admin|login|sys|managetem|password|username</p><p>查找可注入点：site:域名 inurl:aspx|jsp|php|asp</p><p>查找上传漏洞：site:域名 inurl:file|load|editor|Files</p><p>找eweb编辑器：site:域名 inurl:ewebeditor|editor|uploadfile|eweb|edit</p><p>存在的数据库：site:域名 filetype:mdb|asp|#</p><p>查看脚本类型：site:域名 filetype:asp/aspx/php/jsp</p><p>迂回策略入侵：inurl:cms/data/templates/images/index/ </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nmap工具</title>
      <link href="2021/03/18/namp%E5%B7%A5%E5%85%B7/"/>
      <url>2021/03/18/namp%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="nmap工具"><a href="#nmap工具" class="headerlink" title="nmap工具"></a>nmap工具</h1><h2 id="nmap简介"><a href="#nmap简介" class="headerlink" title="nmap简介"></a>nmap简介</h2><blockquote><p><strong>官方介绍:</strong>  Nmap（“网络映射器”）是免费开放源代码（<a href="https://nmap.org/npsl/">许可证</a>）实用程序，用于网络发现和安全审核。许多系统和网络管理员还发现它对于诸如网络清单，管理服务升级计划以及监视主机或服务正常运行时间之类的任务很有用。</p><p>Nmap以新颖的方式使用原始IP数据包来确定网络上可用的主机，这些主机提供的服务（应用程序名称和版本），它们正在运行的操作系统（和OS版本），包过滤器/防火墙的类型。</p><p>正在使用中，还有许多其他特性。它旨在快速扫描大型网络，但可以在单个主机上正常运行。Nmap可在所有主要的计算机操作系统上运行，并且官方二进制程序包可用于Linux，Windows和Mac OSX。除了经典的命令行Nmap可执行文件之外，<a href="https://nmap.org/zenmap/">Zenmap</a>），灵活的数据传输，重定向和调试工具（<a href="https://nmap.org/ncat/">Ncat</a>），用于比较扫描结果的实用程序（<a href="https://nmap.org/ndiff/">Ndiff</a>）以及数据包生成和响应分析工具（<a href="https://nmap.org/nping/">Nping</a>）。</p><p><a href="https://nmap.org/">官网</a></p><p><strong>我的理解</strong>:nmap一个强大的网络扫描器，在网络安全中它是一个非常重要的工具</p></blockquote><h2 id="nmap下载"><a href="#nmap下载" class="headerlink" title="nmap下载"></a>nmap下载</h2><blockquote><p>nmap下载非常简单，去官网找到它的安装包下载下来，安装一切ok,同时nmap也有图形化界面zenmap.</p></blockquote><h2 id="nmap使用"><a href="#nmap使用" class="headerlink" title="nmap使用"></a>nmap使用</h2><ul><li><p>主机发现</p><ul><li><p>一些参数命令的解释</p><p><strong>nmap提供了非常多的命令参数，来供使用者使用</strong></p><p>下面介绍几个常用的参数</p><blockquote><p>ip/24   :探查子网主机</p><p>-O :探查操作系统</p><p>-A：启用OS检测和版本检测</p><p>-sL：列表扫描-仅列出要扫描的目标</p><p>-sP：Ping扫描-只能确定主机是否在线,快速扫描</p><p>-P0：将所有主机视为在线-跳过主机发现</p><p>-sV（版本探测）：版本探测。您也可以用-A同时打开操作系统探测和版本探测</p><p>–excludefile <exclude_file>：从文件中排除列表</p><p>–exclude    排除单个ip</p><p>-T [0-6]：设置计时模板（越高速度越快）</p><p>-e <iface >：使用指定的接口<code>nmap -e wlan0 ip</code></p><p>-p  :只扫描指定端口</p><p>-v (提高输出信息的详细度)</p><blockquote><p>:这个选项使用两次，会提供更详细的信息。这个选 项使用两次以上不起作用。</p></blockquote></blockquote></li><li><p>一些扫描常用语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nmap ip           #经典命令</span><br><span class="line">nmap -O ip           #探测目标操作系统</span><br><span class="line">nmap -A ip</span><br><span class="line">nmap ip&#x2F;24        #通常用于探测子网</span><br><span class="line">nmap  -sP   ip     #快速探测网络中存活的主机</span><br><span class="line">nmap 192.168.1.1&#x2F;24 --exclude 192.168.1.106      #主机过滤</span><br><span class="line">nmap --stats-every 2s  192.168.1.1&#x2F;24       #每隔两秒输出探测进度</span><br><span class="line">nmap -sI 伪装ip  目标ip           #伪装探测</span><br><span class="line">nmap 192.168.1.1&#x2F;24 --excludefile   文件名</span><br><span class="line">nmap  -sT -Pn 172.23.1-255.*</span><br><span class="line">nmap --iflist</span><br></pre></td></tr></table></figure></li><li><p>一些常用命令的详细解释</p><ul><li><p><strong>-iR <hostnum>（随机选择目标）</strong></p><blockquote><p>对于互联网范围内的调查和研究，您也许想随机地选择目标。*<hostnum>*选项告诉Nmap的生成多少个IP。不合需要的IP如特定的私有，组播或者未分配的地址自动略过。选项0意味着永无休止的扫描。记住，一些网管对于未授权的扫描可能会很感冒并引起重叠。如果在某个雨天的下午，您觉得实在无聊，试试这个命令<strong>nmap -sS -PS80 -iR 0 -p 80</strong>随机地找一些网站浏览</p></blockquote></li><li><p><strong>-sS（TCP SYN扫描）</strong></p><blockquote><p>它常常被称为半开放扫描，因为它不打开一个完全的TCP连接。</p><p>Tcp SYN Scan (sS) 这是一个基本的扫描方式,它被称为半开放扫描，因为这种技术使得Nmap不需要通过完整的握手，就能获得远程主机的信息。Nmap发送SYN包到远程主机，但是它不会产生任何会话.因此不会在目标主机上产生任何日志记录,因为没有形成会话。这个就是SYN扫描的优势.如果Nmap命令中没有指出扫描类型,默认的就是Tcp SYN.</p></blockquote></li><li><p><strong>-sT（TCP connect（）扫描）</strong></p><blockquote><p>Tcp connect() scan(sT)如果不选择SYN扫描,TCP connect()扫描就是默认的扫描模式.不同于Tcp SYN扫描,Tcp connect()扫描需要完成三次握手,并且要求调用系统的connect().Tcp connect()扫描技术只适用于找出TCP和UDP端口.</p></blockquote></li><li><p><strong>-sU（UDP扫描）</strong></p><blockquote><p>Udp scan(sU)顾名思义,这种扫描技术用来寻找目标主机打开的UDP端口.它不需要发送任何的SYN包，因为这种技术是针对UDP端口的。UDP扫描发送UDP数据包到目标主机，并等待响应,如果返回ICMP不可达的错误消息，说明端口是关闭的，如果得到正确的适当的回应，说明端口是开放的.</p></blockquote></li><li><p>-<strong>FIN扫描（-sF）</strong></p><blockquote><p>FINscan(sF)</p><p>有时候TcpSYN扫描不是最佳的扫描模式,因为有防火墙的存在.目标主机有时候可能有IDS和IPS系统的存在,防火墙会阻止掉SYN数据包。发送一个设置了FIN标志的数据包并不需要完成TCP的握手.</p></blockquote></li><li><p><strong>空扫描（-sN）</strong></p><blockquote><p>不设置任何标志位（tcp标志头是0）</p></blockquote></li><li><p><strong>-sA（TCP ACK扫描）</strong></p><blockquote><p>这种扫描与目前为止讨论的其他扫描的不同之处在于它不能确定open（开放的）或者open | filtered（开放或过滤的）端口。无状态的，某些端口是被过滤的。ACK扫描探测报文只设置ACK标志位（除非您使用–scanflags）。为unfiltered（准确过滤的），意思是ACK报文不能到达，但至于它们是open（开放的）或者closed（关闭的）无法确定。代号1，2，3，9，10，或13）的端口，标记为filtered（被过滤的）。</p></blockquote></li><li><p>版本检测(sV)</p><blockquote><p>版本检测是用来扫描目标主机和端口上运行的软件的版本.它不同于其它的扫描技术，它不是用来扫描目标主机上开放的端口，不过它需要从开放的端口获取信息来判断软件的版本.使用版本检测扫描之前需要先用TCPSYN扫描开放了哪些端口.</p></blockquote></li><li><p>Idlescan(-sL)</p><blockquote><p>Idlescan是一种先进的扫描技术，它不是用你真实的主机Ip发送数据包，而是使用另外一个目标网络的主机发送数据包.</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;nmap-sL  192.168.1.6   192.168.1.1</span><br></pre></td></tr></table></figure><p>Idlescan是一种理想的匿名扫描技术,通过目标网络中的192.168.1.6向主机192.168.1.1发送数据，来获取192.168.1.1开放的端口</p></blockquote></li><li><p>-PN</p><blockquote><p>如果远程主机有防火墙，IDS和IPS系统，你可以使用-PN命令来确保不ping远程主机，因为有时候防火墙会组织掉ping请求.-PN命令告诉Nmap不用ping远程主机。</p></blockquote></li><li><p><strong>-sV (版本探测)</strong></p><blockquote><p>打开版本探测。 您也可以用-A同时打开操作系统探测和版本探测。</p></blockquote></li><li><p><strong>–version-intensity <intensity> (设置 版本扫描强度)</strong></p><blockquote><p>当进行版本扫描(-sV)时，nmap发送一系列探测报文 ，每个报文都被赋予一个1到9之间的值。 被赋予较低值的探测报文对大范围的常见服务有效，而被赋予较高值的报文 一般没什么用。强度水平说明了应该使用哪些探测报文。数值越高， 服务越有可能被正确识别。 然而，高强度扫描花更多时间。强度值必须在0和9之间。 默认是7。当探测报文通过nmap-service-probes ports指示符 注册到目标端口时，无论什么强度水平，探测报文都会被尝试。这保证了DNS 探测将永远在任何开放的53端口尝试， SSL探测将在443端口尝试，等等。</p></blockquote></li><li><p><strong>–version-all (尝试每个探测)</strong></p><blockquote><p>–version-intensity 9的别名， 保证对每个端口尝试每个探测报文</p></blockquote></li><li><p><strong>–version-trace (跟踪版本扫描活动)</strong></p><blockquote><p>这导致Nmap打印出详细的关于正在进行的扫描的调试信息。 它是您用–packet-trace所得到的信息的子集。</p></blockquote></li><li><p><strong>–osscan-limit (针对指定的目标进行操作系统检测)</strong></p><blockquote><p>如果发现一个打开和关闭的TCP端口时，操作系统检测会更有效。 采用这个选项，Nmap只对满足这个条件的主机进行操作系统检测，这样可以 节约时间，特别在使用-P0扫描多个主机时。这个选项仅在使用 -O或-A 进行操作系统检测时起作用</p></blockquote></li></ul></li><li><p><strong>nmap扫描时间和性能</strong></p><ul><li><p><strong>–min-hostgroup <milliseconds>; –max-hostgroup <milliseconds> (调整并行扫描组的大小)</strong></p><blockquote><p>Nmap具有并行扫描多主机端口或版本的能力，Nmap将多个目标IP地址 空间分成组，然后在同一时间对一个组进行扫描。通常，大的组更有效。缺 点是只有当整个组扫描结束后才会提供主机的扫描结果。如果组的大小定义 为50，则只有当前50个主机扫描结束后才能得到报告(详细模式中的补充信息 除外)。</p><p>默认方式下，Nmap采取折衷的方法。开始扫描时的组较小， 最小为5，这样便于尽快产生结果；随后增长组的大小，最大为1024。确切的 大小依赖于所给定的选项。为保证效率，针对UDP或少量端口的TCP扫描，Nmap 使用大的组。</p><p>–max-hostgroup选项用于说明使用最大的组，Nmap不 会超出这个大小。–min-hostgroup选项说明最小的组，Nmap 会保持组大于这个值。如果在指定的接口上没有足够的目标主机来满足所 指定的最小值，Nmap可能会采用比所指定的值小的组。这两个参数虽然很少使用， 但都用于保持组的大小在一个指定的范围之内。</p><p>这些选项的主要用途是说明一个最小组的大小，使得整个扫描更加快速。通常 选择256来扫描C类网段。对于端口数较多的扫描，超出该值没有意义。对于 端口数较少的扫描，2048或更大的组大小是有帮助的。</p></blockquote></li><li><p><strong>–min-parallelism <milliseconds>; –max-parallelism <milliseconds> (调整探测报文的并行度)</strong></p><blockquote><p>这个命令这些选项控制用于主机组的探测报文数量，可用于端口扫描和主机发现。</p><p>这个值为10比较合适，</p><p>–max-parallelism选项通常设为1，以防止Nmap在同一时间 向主机发送多个探测报文，和选择–scan-delay同时使用非常有用</p><p>nmap –max-parallelism 4 192.168.1.103      #最大使用4个并发端口探测</p></blockquote></li><li><p><strong>–min-rtt-timeout <milliseconds>， –max-rtt-timeout <milliseconds>， –initial-rtt-timeout <milliseconds> (调整探测报文超时)</strong></p><blockquote><p>Nmap使用一个运行超时值来确定等待探测报文响应的时间，随后会放弃或重新 发送探测报文.</p></blockquote></li><li><p><strong>–host-timeout <milliseconds> (放弃低速目标主机)</strong></p><blockquote><p>这个选项用于Nmap控制针对一个主机发送探测报文的等待时间(毫秒)，在带宽 控制的情况下这个选项非常有效。</p><p>–scan-delay的另一个用途是躲闭基于阈值的入侵检测和预防 系统(IDS/IPS)。</p></blockquote></li><li><p><strong>–host-timeout <milliseconds> (放弃低速目标主机)</strong></p><blockquote><p>由于性能较差或不可靠的网络硬件或软件、带宽限制、严格的防火墙等原因， 一些主机需要<em>很长</em>的时间扫描。这些极少数的主机扫描往往占 据了大部分的扫描时间。因此，最好的办法是减少时间消耗并且忽略这些主机，使用 –host-timeout选项来说明等待的时间(毫秒)。</p></blockquote></li></ul></li><li><p><strong>nmap与防火墙</strong></p><ul><li><p><strong>防火墙</strong></p><blockquote><p>在网络中，注意隐藏自己，通过对防火墙的设置，可以让一般的ping扫描失效，对于自己不对外开放的端口也可以进行隐藏。</p><p>但是道高一尺，魔高一丈，nmap有自带可以穿透一般防火墙检测的命令。</p></blockquote></li><li><p><strong>-f (报文分段); –mtu (使用指定的MTU)</strong></p><blockquote><p>-f选项要求扫描时(包挺ping扫描)使用 小的IP包分段。其思路是将TCP头分段在几个包中，使得包过滤器、 IDS以及其它工具的检测更加困难.</p><p>使用–mtu选项可 以自定义偏移的大小，使用时不需要-f，偏移量必须 是8的倍数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap -f   192.168.1.106</span><br><span class="line"></span><br><span class="line">nmap --mtu 8 192.168.1.105</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>-D &lt;decoy1 [，decoy2]…&gt; (使用诱饵隐蔽扫描)</strong></p><blockquote><p>这是一种常用的隐藏自身IP地址的有效技术,</p><p>使用逗号分隔每个诱饵主机，也可用自己的真实IP作为诱饵，这时可使用 ME选项说明。如果在第6个位置或 更后的位置使用ME选项，一些常用 端口扫描检测器(如Solar Designer’s excellent scanlogd)就不会报告 这个真实IP。如果不使用ME选项，Nmap 将真实IP放在一个随机的位置</p><p>注意，作为诱饵的主机须在工作状态，否则会导致目标主机的SYN洪水攻击。 如果在网络中只有一个主机在工作，那就很容易确定哪个主机在扫描。也可 使用IP地址代替主机名(被诱骗的网络就不可能在名字服务器日志中发现)。</p><p>诱饵可用在初始的ping扫描(ICMP、SYN、ACK等)阶段或真正的端口扫描 阶段。诱饵也可以用于远程操作系统检测(-O)。在进行版 本检测或TCP连接扫描时，诱饵无效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -D RND:10 192.168.1.1</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>-S <IP_Address> (源地址哄骗)</strong></p><blockquote><p>在某些情况下，Nmap可能无法确定你的源地址(如果这样，Nmap会给出 提示)。此时，使用-S选项并说明所需发送包的接口IP地址。</p><p>这个标志的另一个用处是哄骗性的扫描，使得目标认为是<em>另 一个地址</em>在进行扫描。可以想象某一个竞争对手在不断扫描某个公司！ -e选项常在这种情况下使用，也可采用-P0选项。</p></blockquote></li><li><p><strong>–source-port <portnumber>; -g <portnumber> (源端口哄骗)</strong></p><blockquote><p>仅依赖于源端口号就信任数据流是一种常见的错误配置，这个问题非常 好理解。例如一个管理员部署了一个新的防火墙，但招来了很多用户的不满，因为 他们的应用停止工作了。可能是由于外部的UDP DNS服务器响应无法进入网络，而导致 DNS的崩溃。FTP是另一个常见的例子，在FTP传输时，远程服务器尝试和内部用 建立连接以传输数据。</p></blockquote><blockquote><p>对这些问题有安全解决方案，通常是应用级代理或协议分析防火墙模块。 但也存在一些不安全的方案。注意到DNS响应来自于53端口，FTP连接 来自于20端口，很多管理员会掉入一个陷阱，即允许来自于这些端口的数据进入 网络。他们认为这些端口里不会有值得注意的攻击和漏洞利用。此外，管理员 或许认为这是一个短期的措施，直至他们采取更安全的方案。但他们忽视了安全的 升级。</p></blockquote><blockquote><p>不仅仅是工作量过多的网络管理员掉入这种陷阱，很多产品本身也会有这类 不安全的隐患，甚至是微软的产品。Windows 2000和Windows XP中包含的IPsec过滤 器也包含了一些隐含规则，允许所有来自88端口(Kerberos)的TCP和UDP数据流。另 一个常见的例子是Zone Alarm个人防火墙到2.1.25版本仍然允许源端口53(DNS)或 67(DHCP)的UDP包进入。</p></blockquote><blockquote><p>Nmap提供了-g和–source-port选项(它们是 等价的)，用于利用上述弱点。只需要提供一个端口号，Nmap就可以从这些 端口发送数据。为使特定的操作系统正常工作，Nmap必须使用不同的端口号。 DNS请求会忽略–source-port选项，这是因为Nmap依靠系 统库来处理。大部分TCP扫描，包括SYN扫描，可以完全支持这些选项，UDP扫 描同样如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --source-port 54 192.168.1.106       #指定发送探测包到指定端口</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>–data-length <number> (发送报文时 附加随机数据)</strong></p><blockquote><p>正常情况下，Nmap发送最少的报文，只含一个包头。因此TCP包通常 是40字节，ICMP ECHO请求只有28字节。这个选项告诉Nmap在发送的报文上 附加指定数量的随机字节。操作系统检测(-O)包不受影响， 但大部分ping和端口扫描包受影响，这会使处理变慢，但对扫描的影响较小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --data-length 25 192.168.1.106      #在数据包中添加混淆数据长度为25的数据</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>–spoof-mac &lt;mac address，prefix，or vendor name&gt; (MAC地址哄骗)</strong></p></li></ul></li><li><p><strong>nmap扫描结果的输出</strong></p><ul><li><p><strong>-oN <filespec> (标准输出)</strong></p><blockquote><p>要求将标准输出直接写入指定 的文件.</p><p>nmap -oN      scan.txt     192.168.1.1/24              </p><p>nmap -oX scan.xml  192.168.1.1/24</p></blockquote></li><li><p><strong>-oX <filespec> (XML输出)</strong></p></li><li><p><strong>-oA <basename> (输出至所有格式)</strong></p></li></ul></li><li><p><strong>细节与调试</strong></p><ul><li><p><strong>–packet-trace (跟踪发送和接收的报文)</strong></p><blockquote><p>要求Nmap打印发送和接收的每个报文的摘要，通常用于 调试，有助于新用户更好地理解Nmap的真正工作。为避免输出过 多的行，可以限制扫描的端口数，如-p20-30。 如果只需进行版本检测，使用–version-trace。</p></blockquote></li><li><p><strong>–iflist (列举接口和路由)</strong></p><blockquote><p>输出Nmap检测到的接口列表和系统路由，用于调试路由 问题或设备描述失误(如Nmap把PPP连接当作以太网对待)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --iflist</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>-6 (启用IPv6扫描)</strong></p></li><li><p><strong>-A (激烈扫描模式选项)</strong></p><blockquote><p>这个选项启用额外的高级和高强度选项，目前还未确定代表 的内容。目前，这个选项启用了操作系统检测(-O) 和版本扫描(-sV)，以后会增加更多的功能。 目的是启用一个全面的扫描选项集合，不需要用户记忆大量的 选项。这个选项仅仅启用功能，不包含用于可能所需要的 时间选项(如-T4)或细节选项(-v)。</p></blockquote></li></ul></li><li><p><strong>nmap自带的脚本库</strong></p><ul><li><p>常用扫描脚本</p><blockquote><p>留待后续补充</p></blockquote></li><li><p>常用扫描</p><blockquote><p>nmap –script 脚本  ip             #使用脚本对目标ip进行扫描</p><p>nmap –script “http*” ip          #使用所有以http开头的脚本进行扫描</p><p>nmap –script-updatedb         #更新脚本库</p></blockquote></li></ul></li></ul></li></ul><blockquote><p>nmap –randomize-hosts 192.168.1.1-100        </p><p>nmap –badsum 192.168.1.106      </p><p>nmap -Pn -sS -p 80 -iR 0 –open      #随机探测80端口开放的主机</p><p>nmap –inital-rtt-timeout  6000 192.168.1.1     </p><p>nmap –rtt-timeout 350  192.168.1.105       #超时350毫秒</p><p>nmap –max-retries 3 192.168.1.105    #进行至少3次尝试</p><p>nmap –ttl 100 192.168.1.105    #发送数据包</p><p>nmap –host-timeout 1m ip        </p><p>nmap –min-rate 50 ip</p><p>nmap –max-rate 10 ip</p><p>nmap –script 脚本  ip</p></blockquote><ul><li><p><strong>nmap踩过的坑</strong></p><blockquote><p>nmap 扫描报错</p><p>原因：使用拨号上网，协议 使用的是ppp，nmap不识别</p><p>解决：加上 -sT -Pn  两个参数即可</p></blockquote></li></ul><p><a href="https://svn.nmap.org/nmap/docs/nmap.usage.txt">官方文档</a></p><p><a href="http://www.nmap.com.cn/doc/manual.shtm#1">中文官方文档</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>xss-csrf的关系</title>
      <link href="2021/03/17/xss-csrf/"/>
      <url>2021/03/17/xss-csrf/</url>
      
        <content type="html"><![CDATA[<h1 id="xss和csrf的关系"><a href="#xss和csrf的关系" class="headerlink" title="xss和csrf的关系"></a>xss和csrf的关系</h1><ul><li><h2 id="xss-跨站脚本攻击"><a href="#xss-跨站脚本攻击" class="headerlink" title="xss(跨站脚本攻击)"></a>xss(跨站脚本攻击)</h2><ul><li><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3></li></ul><blockquote><p>跨站脚本攻击是指恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p></blockquote><ul><li><h3 id="xss分类"><a href="#xss分类" class="headerlink" title="xss分类"></a>xss分类</h3><ul><li><h4 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h4></li></ul><blockquote><p>&lt;非持久化&gt;攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。</p></blockquote><ul><li><h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4></li></ul><blockquote><p>&lt;持久化&gt; 代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie</p></blockquote><ul><li><h4 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h4><blockquote><p>dom型xss是一种基于页面dom树而造成的漏洞，后端没有关系，通过拼接用户的输入不经过服务器，而直接输出拼接成恶意攻击代码。</p></blockquote></li></ul></li><li><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3></li></ul><blockquote><p>xss的实质是没有对用户的输入进行转义，而当成代码来执行的。是一种注入网页前端代码的”艺术”，常用语言是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。</p></blockquote><ul><li><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><blockquote><p>1、盗用<a href="https://baike.baidu.com/item/cookie/1119">cookie</a>，获取敏感信息。<br>2、利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用<a href="https://baike.baidu.com/item/Java/85979">Java</a>等得到类似的操作。<br>3、利用<a href="https://baike.baidu.com/item/iframe/4446518">iframe</a>、frame、<a href="https://baike.baidu.com/item/XMLHttpRequest/6788735">XMLHttpRequest</a>或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。<br>4、利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。<br>5、在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果。</p></blockquote></li><li><h3 id="漏洞注入测试语句和绕过"><a href="#漏洞注入测试语句和绕过" class="headerlink" title="漏洞注入测试语句和绕过"></a>漏洞注入测试语句和绕过</h3><ul><li><h4 id="xss绕过"><a href="#xss绕过" class="headerlink" title="xss绕过"></a>xss绕过</h4><ul><li><p>如果script大小写被过滤</p><ol><li><p>则使用 <code>&lt;img src=1 οnerrοr=alert(1)&gt;</code></p><blockquote><p>表示插入一个图片 图片路径错误无法显示 onerror事件 触发</p></blockquote></li><li><p>构造a标签，使其中的script进行<a href="https://www.qqxiuzi.cn/bianma/zifushiti.php">HTML字符实体转换</a>。</p><blockquote><p>使用url编码也可以<br>t 转换为 &#x74;<br>则可以使用伪协议：javascrip&#x74;:alert(1)</p></blockquote></li><li><p><code>&quot;&gt;[haha</code></p><blockquote><p>如果是输出在a标签中则可直接使用 javascript:alert(1)</p></blockquote></li><li><p>script中间插入制表符<img src="https://api2.mubu.com/v3/document_image/9448f2d9-7a67-4f4d-a1c8-574d316d39da-9600879.jpg" alt="img"></p><blockquote><p>这里使用 &amp;#x9<br>“&gt;&lt;a href=”java&amp;#x9script:alert(1)</p></blockquote></li></ol></li><li><p>Alert被过滤 可以使用confirm()、prompt()</p></li></ul><p>例 : </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;confirm()&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>利用javascript：伪协议绕过</strong>实例:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;iframe src&#x3D;javascript:alert(1)&gt;</span><br><span class="line">“&gt;&lt;a href&#x3D;&quot;javascript:alert(1)&quot;&gt;haha&lt;&#x2F;a&gt; 或者：”&gt;&lt;a href&#x3D;&quot;javascript:alert(1)&quot;&gt;haha</span><br><span class="line">    </span><br><span class="line">&lt;input name&#x3D;keyword value&#x3D;&quot; &quot;&gt;&lt;a href&#x3D;&quot;javascript:alert(1)&quot;&gt;haha&lt;&#x2F;a&gt;&quot;&gt;</span><br><span class="line"> &lt;input name&#x3D;keyword value&#x3D;&quot; &quot;&gt;&lt;a href&#x3D;&quot;javascript:alert(1)&quot;&gt;haha&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li><h5 id="如果（）不能用-可以用-反引号如果-空格被过滤可以使用-0a-或-0d-或"><a href="#如果（）不能用-可以用-反引号如果-空格被过滤可以使用-0a-或-0d-或" class="headerlink" title="如果（）不能用 可以用  反引号如果 空格被过滤可以使用 %0a 或 %0d 或/**/"></a>如果（）不能用 可以用  反引号如果 空格被过滤可以使用 %0a 或 %0d 或/**/</h5></li><li><h5 id="如果是被-加了反斜杠-l过滤-双引号-这种过滤"><a href="#如果是被-加了反斜杠-l过滤-双引号-这种过滤" class="headerlink" title="如果是被 加了反斜杠 \ l过滤 双引号 这种过滤"></a>如果是被 加了反斜杠 \ l过滤 双引号 这种过滤</h5><blockquote><p>过滤 双引号：在alert中实体转换alert(&quot;XSS&quot;)<br>使用JavaScript的fromCharCode函数绕过过滤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;IMGSRC&#x3D;javascript:alert(String.fromCharCode(88,83,83))&gt;</span><br></pre></td></tr></table></figure></blockquote><h6 id="使用没有双引号的"><a href="#使用没有双引号的" class="headerlink" title="使用没有双引号的:"></a>使用没有双引号的:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;IMG SRC&#x3D;javascript：alert(‘XSS’)&gt;</span><br></pre></td></tr></table></figure></li><li><h5 id="xss宽字节绕过"><a href="#xss宽字节绕过" class="headerlink" title="xss宽字节绕过"></a>xss宽字节绕过</h5><blockquote><p>宽字节绕过的条件：<br>返回页面·是GBK/GB2312编码的；<br>通过构造UNicode字符让双引号逃逸出来。<br>例如:<br>%c1\会被认为一个UNicode字符</p></blockquote></li><li><h5 id="使用注释符绕过长度限制"><a href="#使用注释符绕过长度限制" class="headerlink" title="使用注释符绕过长度限制;"></a>使用注释符绕过长度限制;</h5><p>情况一：</p><p>例如两个文本框，input元素，限制了长度不允许写入更多东西，这时候可以使用注释符绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;inuput id&#x3D;1 type&#x3D;&quot;text&quot; value&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">xxxxxxxxx</span><br><span class="line">&lt;input id&#x3D;2 type&#x3D;&quot;text&quot; value&#x3D;&quot;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>方法:</p><p>在第一个input框中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;!--</span><br></pre></td></tr></table></figure><p>在第一二个框中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&gt;&lt;script&gt;alert(&#x2F;xss&#x2F;);&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>最终效果;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;inuput id&#x3D;1 type&#x3D;&quot;text&quot; value&#x3D;&quot;&quot;&gt;&lt;! --&quot; &#x2F;&gt;</span><br><span class="line">xxxxxxxx</span><br><span class="line">&lt;input id&#x3D;2 type&#x3D;&quot;text&quot; value&#x3D;&quot;--&gt;&lt;script&gt;alert(&#x2F;xss&#x2F;);&lt;&#x2F;script&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure></li><li><p>绕过magic_quotes_gpc()</p><blockquote><p>magic_quotes_gpc=ON是php中的安全设置，开启后会把一些特殊字符进行轮换，比如’(单引号)转换为\’，”(双引号)转换为\”，\转换为\</p><p>比如：<code>&lt;script&gt;alert(“xss”);&lt;/script&gt;</code>会转换为<code>&lt;script&gt;alert(\”xss\”);&lt;/script&gt;</code>,这样我们的xss就不生效了。</p><p>针对开启了magic_quotes_gpc的网站，我们可以通过javascript中的<strong>String.fromCharCode</strong>方法来绕过，我们可以把alert(“XSS”);转换为<br>**<code>String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34,41)</code>**那么我们的XSS语句就变成了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88,83, 83, 34, 41, 59)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>String.fromCharCode()是javascript中的字符串方法，用来把ASCII转换为字符串。<br>最后使用<code>&lt;script&gt;转换后的放到这里&lt;/script&gt;</code>包含即可</p></blockquote></li><li><p>使用编码绕过xss</p><ul><li><p>使用hex编码绕过</p><blockquote><p>我们可以对我们的语句进行hex编码来绕过XSS规则<br>比如：<script>alert(“xss”);</script>可以转换为：<br>%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%22%78%73%73%22%29%3b%3c%2f%73%63%72%69%70%74%3e</p></blockquote></li><li><p>html实体编码</p></li><li><p>十进制，八进制，十六进制编码</p></li><li><p>unicode编码</p></li><li><p>escape编码</p></li><li><p>String.fromCharCode(…)   (ascii编码)</p></li></ul></li><li><p><a href="https://blog.csdn.net/free_xiaochen/article/details/82289316">更多1</a>    <a href="https://blog.csdn.net/suifengshiyu/article/details/22335239">更多2</a></p></li></ul></li><li><h3 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h3><blockquote><p>**htmlentities() :**把预定义的字符 “&lt;” （小于）和 “&gt;” （大于）转换为 HTML 实体<br><strong>htmlspecialchars和htmlentities的区别：</strong><br>htmlspecialchars 只转义 <code>&amp; 、&quot; 、&#39; 、&lt; 、&gt; </code>这几个html代码，而 htmlentities 却会转化所有的html代码，连同里面的它无法识别的中文字符也会转化。</p></blockquote><ol><li> 编码：</li></ol><blockquote><p>对用户输入的数据进行<br>HTML Entity 编码。<br>如上图所示，把字符转换成 转义字符。<br>Encode的作用是将<br>$var<br>等一些字符进行转化，使得浏览器在最终输出结果上是一样的。<br>比如说这段代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。<br>进行编码处理之后，L在浏览器中的显示结果就是</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>，实现了将$var作为纯文本进行输出，且不引起JavaScript的执行。</p></blockquote><p>2.过滤：</p><blockquote><p>移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。（总而言是，过滤掉一些不安全的内容）移除用户输入的Style节点、Script节点、Iframe节点。（尤其是Script节点，它可是支持跨域的呀，一定要移除）。</p></blockquote><p>3、校正</p><blockquote><p>避免直接对HTML Entity进行解码。使用DOM Parse转换，校正不配对的DOM标签。备注：我们应该去了解一下<br>DOM Parse<br>这个概念，它的作用是把文本解析成DOM结构。<br>比较常用的做法是，通过第一步的编码转成文本，然后第三步转成DOM对象，然后经过第二步的过滤。<br>还有一种简洁的答案：<br>首先是encode，如果是富文本，就白名单<br><a href="http://blog.nsfocus.net/xss-advance/">更多</a></p></blockquote></li></ul></li></ul></li><li><h3 id="区别-参考资料"><a href="#区别-参考资料" class="headerlink" title="区别     参考资料"></a>区别     <a href="https://www.cnblogs.com/itsuibi/p/10752868.html">参考资料</a></h3><h4 id="区别一："><a href="#区别一：" class="headerlink" title="区别一："></a>区别一：</h4><blockquote><p>CSRF：需要用户先登录网站A，获取 cookie。XSS：不需要登录。</p></blockquote><h4 id="区别二：（原理的区别）"><a href="#区别二：（原理的区别）" class="headerlink" title="区别二：（原理的区别）"></a>区别二：（原理的区别）</h4><blockquote><p>CSRF：是利用网站A本身的漏洞，去请求网站A的api。XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
          <category> csrf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csrf，ssrf小结</title>
      <link href="2021/03/17/csrf-ssrf/"/>
      <url>2021/03/17/csrf-ssrf/</url>
      
        <content type="html"><![CDATA[<h1 id="csrf，ssrf小结"><a href="#csrf，ssrf小结" class="headerlink" title="csrf，ssrf小结"></a>csrf，ssrf小结</h1><h2 id="csrf和ssrf的区别"><a href="#csrf和ssrf的区别" class="headerlink" title="csrf和ssrf的区别"></a>csrf和ssrf的区别</h2><ul><li><h2 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a>csrf</h2><ul><li><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote><p>CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性。你可以这样来理解：       攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。</p></blockquote></li><li><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p>攻击者通过盗用用户的身份标识-cookie，而服务器没有做再一次验证用户的身份，就会造成csrf漏洞</p></blockquote></li><li><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><blockquote><p>利用钓鱼·，或者和xss一起使用·，</p><pre><code> 利用场景，用户A登录网站A时，在用户A还没有退出网站A时，点击了一个来自黑客B伪造的链接，这个链接是可以用来对网站A用户修改密码的，用户A点击后，网站A验证的是用户A cookie，服务器认为这是用户A发起的连接，是正常的。</code></pre></blockquote></li><li><h4 id="防御csrf"><a href="#防御csrf" class="headerlink" title="防御csrf"></a>防御csrf</h4><blockquote><p>目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。</p><ul><li>方法一、Token 验证：（用的最多）</li></ul><blockquote><p>（1）服务器发送给客户端一个token；<br> （2）客户端提交的表单中带着这个token。<br> （3）如果这个 token 不合法，那么服务器拒绝这个请求。</p></blockquote><ul><li>方法二：隐藏令牌：</li></ul><blockquote><p>把 token 隐藏在 http 的 head头中。<br>方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别</p></blockquote><ul><li>方法三、Referer 验证：</li></ul><blockquote><p>Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截</p></blockquote></blockquote></li></ul></li><li><h2 id="ssrf"><a href="#ssrf" class="headerlink" title="ssrf"></a>ssrf</h2><ul><li><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><blockquote><p>SSRF(Server-side Request Forge, 服务端请求伪造)。<br>由攻击者构造的攻击链接传给服务端执行造成的漏洞，一般用来在外网探测或攻击内网服务</p></blockquote></li><li><h4 id="ssrf用到的协议类型"><a href="#ssrf用到的协议类型" class="headerlink" title="ssrf用到的协议类型"></a>ssrf用到的协议类型</h4><blockquote><ul><li><h5 id="gopher协议"><a href="#gopher协议" class="headerlink" title="gopher协议"></a>gopher协议</h5></li></ul><blockquote><p>gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议。</p></blockquote><ul><li><h6 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a><font color=red>利用</font></h6><blockquote><p>暂时留空</p></blockquote></li><li><h5 id="dict协议"><a href="#dict协议" class="headerlink" title="dict协议"></a>dict协议</h5></li></ul><blockquote><p>词典网络协议，在RFC 2009中进行描述。它的目标是超越Webster protocol，并允许客户端在使用过程中访问更多字典。Dict服务器和客户机使用TCP端口2628。（摘自百度百科）</p></blockquote><ul><li><h5 id="file协议"><a href="#file协议" class="headerlink" title="file协议"></a>file协议</h5></li></ul><blockquote><p>file协议主要用于访问本地计算机中的文件，命令格式为： file://文件路径</p></blockquote><ul><li><h5 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h5></li></ul><blockquote><p>http是访问本地的html文件，相当于把本机当作http服务器，通过http访问服务器，服务器再去访问本地资源</p></blockquote></blockquote></li><li><p><strong>原理</strong></p><blockquote><p>​          SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。</p><p>比如从指定URL地址获取网页文本内容，加载指定地址的图片，文档，等等。</p><p> 比如 ： A网站，是一个所有人都可以访问的外网网站，B网站是一个他们内部的OA网站。 所以，我们普通用户只可以访问a网站，不能访问b网站。</p><p>但是我们可以同过a网站做中间人，访问b网站，从而达到攻击b网站需求。</p></blockquote></li><li><p><strong>利用，用途</strong></p><blockquote><p>1、可对内网，服务器所在内网，受控服务器进行端口扫描，获取一些banner 　</p><p>2、对内网web应用进行指纹识别，通过访问默认文件实现。 　</p><p>3、攻击内外网web应用，主要是使用get参数就可以实现分攻击。 　</p><p>4、利用file协议读取本地文件。</p></blockquote></li></ul></li><li><h3 id="cssf与ssrf区别"><a href="#cssf与ssrf区别" class="headerlink" title="cssf与ssrf区别"></a>cssf与ssrf区别</h3><blockquote><p>总的来说，CSRF是服务器端没有对用户提交的数据进行严格的把控，导致攻击者可以利用用户的Cookie信息伪造用户请求发送至服务器。而SSRF是服务器对用户提供的可控URL地址过于信任，没有经过严格检测，导致攻击者可以以此为跳板攻击内网或其他服务器。</p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入绕过方式</title>
      <link href="2021/03/17/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F/"/>
      <url>2021/03/17/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="sql注入的绕过方式"><a href="#sql注入的绕过方式" class="headerlink" title="sql注入的绕过方式"></a>sql注入的绕过方式</h1><ul><li><p><strong>注释符号绕过</strong><br>在sql中常用的注释符号有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--、#、&#x2F;*xxx*&#x2F;、;</span><br></pre></td></tr></table></figure></li><li><p><strong>大小写绕过</strong></p><blockquote><p>当web正则过滤的时候对大小写不敏感的情况下使用，一般很少会有这种漏洞<br>　　比如当过滤了select的时候我们可以采用SEleCT来查询</p></blockquote></li><li><p><strong>内联注释绕过</strong></p><blockquote><p>  内联注释就是把一些特有的仅在MYSQL上的语句放在 /<em>!…</em>/ 中，这样这些语句如果在其它数据库中是不会被  执行，但在MYSQL中会执行。</p></blockquote></li><li><p><strong>双写关键字绕过</strong></p><blockquote><p>在某一些简单的waf中，将关键字select等只使用replace()函数置换为空，这时候可以使用双写关键字绕过。 例如select变成seleselectct，在经过waf的处理之后又变成select，达到绕过的要求。</p></blockquote></li><li><p><strong>特殊编码绕过</strong></p><blockquote><p>对于一些waf会对关键字进行过滤，或禁止使用，这时候通过编码的方式是一个很好的绕过方式</p></blockquote><ul><li><p><strong>十六进制绕过</strong></p></li><li><p><strong>ascii编码绕过</strong></p><blockquote><p>Test 等价于<br>CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)<br>tip:好像新版mysql不能用了<br>空格过滤绕过</p></blockquote></li><li><p><strong>base64编码绕过</strong></p></li><li><p><strong>url二次编码绕过</strong></p></li></ul></li><li><p><strong>空格过滤绕过</strong></p><blockquote><p>一般绕过空格过滤的方法有以下几种方法来取代空格；<br>/**/<br>()<br>回车(url编码中的%0a)<br>`(tap键上面的按钮)<br>tap<br>两个空格</p></blockquote></li><li><p><strong>过滤or and  xor not</strong></p><blockquote><p>and = &amp;&amp;<br>or = ||<br>xor = | # 异或<br>not = !</p></blockquote></li><li><p><strong>过滤等号=绕过</strong></p><blockquote><p>不加通配符的like执行的效果和=一致，所以可以用来绕过</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username <span class="keyword">like</span> &quot;test%&quot;;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="keyword">like</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>rlike:模糊匹配，只要字段的值中存在要查找的 部分 就会被选择出来<br>用来取代=时，rlike的用法和上面的like一样，没有通配符效果和=一样<br>​<br>regexp:MySQL中使用 REGEXP 操作符来进行正则表达式匹配</p></blockquote><ul><li><p><strong>使用大小于号来绕过</strong><img src="https://api2.mubu.com/v3/document_image/4e45d93c-2a44-4973-8988-80fd9f554770-9600879.jpg" alt="img"></p></li><li><p><strong>&lt;&gt; 等价于 !=    所以在前面再加一个!结果就是等号了</strong><img src="https://api2.mubu.com/v3/document_image/2740379a-761e-4cec-9b61-4e6ff55b2336-9600879.jpg" alt="img"></p></li><li><p><strong>等号绕过也可以使用strcmp(str1,str2)函数、between关键字等，具体可以参考后面的过滤大小于号绕过</strong></p></li></ul></li><li><p><strong>过滤大小于号绕过</strong></p><blockquote><p>在sql盲注中，一般使用大小于号来判断ascii码值的大小来达到爆破的效果。但是如果过滤了大小于号的话，那就凉凉。怎么会呢，可以使用以下的关键字来绕过；</p></blockquote><ul><li><strong>greatest(n1, n2, n3…):返回n中的最大值</strong></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> greatest(ascii(substr(username,<span class="number">1</span>,<span class="number">1</span>)),<span class="number">1</span>)<span class="operator">=</span><span class="number">116</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>least(n1,n2,n3…):返回n中的最小值</strong></p></li><li><p><strong>strcmp(str1,str2):若所有的字符串均相同，则返回STRCMP()，若根据当前分类次序，第一个参数小于第二个，则返回 -1，其它情况返回 1</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id &#x3D; 1 and strcmp(ascii(substr(username,1,1)),117);</span><br></pre></td></tr></table></figure><ul><li><strong>in关键字</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id &#x3D; 1 and substr(username,1,1) in (&#39;t&#39;);</span><br></pre></td></tr></table></figure><ul><li><p><strong>between a and b:范围在a-b之间</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id between 1 and 2;</span><br><span class="line">select * from users where id &#x3D; 1 and substr(username,1,1) between &#39;a&#39; and &#39;b&#39;;</span><br><span class="line">使用between a and b判等</span><br><span class="line">select * from users where id &#x3D; 1 and substr(username,1,1) between &#39;t&#39; and &#39;t&#39;;</span><br></pre></td></tr></table></figure></li><li><p><strong>过滤引号绕过</strong></p></li><li><p>使用十六进制编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select column_name  from information_schema.tables where table_name&#x3D;0x7573657273;</span><br></pre></td></tr></table></figure></li><li><p>宽字节</p><blockquote><p>常用在web应用使用的字符集为GBK时，并且过滤了引号，就可以试试宽字节。<br># 过滤单引号时<br>%bf%27<br> %df%27<br>%aa%27<br>​<br>%df\’ = %df%5c%27=縗’</p></blockquote><ul><li>查看字符集的语句</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;%character%&#39;;</span><br><span class="line">show create database 库名.</span><br></pre></td></tr></table></figure></li><li><p><strong>过滤逗号绕过</strong></p><p>sql盲注时常用到以下函数:</p><ul><li><p>substr()</p><blockquote><p>substr(string, pos, len):从pos开始，取长度为len的子串<br>substr(string, pos):从pos开始，取到string的最后</p></blockquote></li></ul></li><li><p>substring()</p><blockquote><p>用法和substr()一样</p></blockquote><ul><li>mid()</li></ul></li></ul><blockquote><p>用法和substr()一样，但是mid()是为了向下兼容VB6.0，已经过时，以上的几个函数的pos都是从1开始的</p></blockquote><ul><li><p>left()和right()</p><blockquote><p>left(string, len)和right(string, len):分别是从左或从右取string中长度为len的子串</p></blockquote><ul><li>limit</li></ul><blockquote><p>imit pos len:在返回项中从pos开始去len个返回值，pos的从0开始</p></blockquote><ul><li>ascii()和char()</li></ul><blockquote><p>ascii(char):把char这个字符转为ascii码<br>char(ascii_int):和ascii()的作用相反，将ascii码转字符</p></blockquote><ul><li><p>回到正题，</p><blockquote><p>如果waf过滤了逗号，并且只能盲注（盲注基本离不开逗号啊喂），在取子串的几个函数中，有一个替代逗号的方法就是使用from pos for len，其中pos代表从pos个开始读取len长度的子串</p></blockquote><ul><li>例如在substr()等函数中，常规的写法是</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select substr(&quot;string&quot;,1,3);</span><br></pre></td></tr></table></figure><ul><li>如果过滤了逗号，可以这样使用from pos for len来取代</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select substr(&quot;string&quot; from 1 for 3);</span><br></pre></td></tr></table></figure><ul><li><p>在sql盲注中，如果过滤逗号，以下参考下面的写法绕过</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  select ascii(substr(database() from 1 for 1)) &gt; 120;</span><br><span class="line">select ascii(substr(database() from 1 for 1)) &gt; 110;</span><br></pre></td></tr></table></figure><ul><li><p>也可以使用join关键字绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from users  union select * from (select 1)a join (select 2)b join(select 3)c;</span><br><span class="line">其中</span><br><span class="line">union select * from (select 1)a join (select 2)b join(select 3)c</span><br><span class="line">等价于</span><br><span class="line">union select 1,2,3</span><br></pre></td></tr></table></figure></li><li><p>使用like关键字</p><blockquote><p>适用于substr()等提取子串的函数中的逗号<br>select ascii(substr(user(),1,1))=114;<br>select user() like “r%”;<br>select user() like “t%”;</p></blockquote></li><li><p>使用offset关键字</p><blockquote><p>适用于limit中的逗号被过滤的情况<br>limit 2,1等价于limit 1 offset 2</p></blockquote></li></ul></li></ul></li><li><p><strong>过滤函数绕过</strong></p><ul><li><p>sleep-&gt;benchmark()</p><blockquote><p># MySQL有一个内置的BENCHMARK()函数，可以测试某些特定操作的执行速度。 参数可以是需要执行的次数和表达式。第一个参数是执行次数，第二个执行的表达式<br>select 12,23 and benchmark(1000000000,1);</p></blockquote></li><li><p>ascii()–&gt;hex()、bin()</p></li></ul><blockquote><p>替代之后再使用对应的进制转string即可</p></blockquote><ul><li><p>group_concat()–&gt;concat_ws()</p><blockquote><p>select group_concat(“str1”,”str2”);<br>select concat_ws(“,”,”str1”,”str2”);第一个参数是分隔符</p></blockquote></li></ul></li><li><p>substr(),substring(),mid()可以相互取代, 取子串的函数还有left(),right()</p><ul><li><p>user() –&gt; @@user、datadir–&gt;@@datadir</p></li><li><p>ord()–&gt;ascii():这两个函数在处理英文时效果一样，但是处理中文等时不一致。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透-本机信息收集</title>
      <link href="2021/03/17/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E6%9C%AC%E6%9C%BA%E4%BF%A1%E6%81%AF/"/>
      <url>2021/03/17/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E6%9C%AC%E6%9C%BA%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="一些查看本机配置信息的命令"><a href="#一些查看本机配置信息的命令" class="headerlink" title="一些查看本机配置信息的命令"></a>一些查看本机配置信息的命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ipconfig &#x2F;all  #网络信息</span><br><span class="line"></span><br><span class="line">systeminfo    #本机的一些硬件和系统信息，非常重要的一个命令</span><br><span class="line"></span><br><span class="line">echo %PROCESSOR_ARCHITECTURE%     #可以查看是64位的系统还是32位的系统</span><br><span class="line"></span><br><span class="line">wmic product get name,version     #查看安装软件的版本及版本信息</span><br><span class="line"></span><br><span class="line">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot; #powershell查看软件版本方法，和上面的命令一样的效果</span><br><span class="line"></span><br><span class="line">wmic service list brief   #本机服务信息</span><br><span class="line"></span><br><span class="line">tasklist #查看进程列表   wmic process list brief </span><br><span class="line"></span><br><span class="line">wmic startup get command ,caption   #查看启动程序信息</span><br><span class="line"></span><br><span class="line">schtasks &#x2F;query &#x2F;fo LIST &#x2F;V       #查看计划任务</span><br><span class="line"></span><br><span class="line">net statistics workstation      #查看主机开机时间</span><br><span class="line"></span><br><span class="line">net user    #查看本机用户列表</span><br><span class="line"></span><br><span class="line">net localgroup administrators    #查看本地管理员</span><br><span class="line"></span><br><span class="line">query user ||qwinsta         #查看当前在线用户</span><br><span class="line"></span><br><span class="line">net session            #列出或断开本地计算机与所远程连接得客户端之间的会话</span><br><span class="line"></span><br><span class="line">netstat -ano          #查看端口列表</span><br><span class="line"></span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn    #查看安装在系统中的补丁</span><br><span class="line"></span><br><span class="line">net share       #查看本机共享列表和和可访问的域共享列表</span><br><span class="line"></span><br><span class="line">wmic share get name,path,status      #利用wmic命令查看共享列表</span><br><span class="line"></span><br><span class="line">route print  #查询路由表</span><br><span class="line"></span><br><span class="line">arp -a    #arp缓存表</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/baby123/p/12867280.html">wmic传送门</a></p><h2 id="一些安全配置和查找"><a href="#一些安全配置和查找" class="headerlink" title="一些安全配置和查找"></a>一些安全配置和查找</h2><ul><li><p>防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show config     #查看防火墙配置</span><br><span class="line"></span><br><span class="line">net firewall set opmode disable   #window Server 2003及之前的版本使用它关闭防火墙</span><br><span class="line"></span><br><span class="line">net advfirewall set allprofiles state off    #window Server 2003之后的版本使用它关闭防火墙</span><br><span class="line"></span><br><span class="line">netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable    #window Server 2003及之前的版本使用它指定程序越过防火墙</span><br><span class="line"> </span><br><span class="line">netsh advfirewall firewall add rule name&#x3D;&quot;pass nc&quot; dir&#x3D;in action&#x3D;allow  program&#x3D;&quot;C: \nc.exe&quot; #window Server 2003之后的版本</span><br><span class="line"></span><br><span class="line">netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allow    #准许3389端口放行</span><br><span class="line"></span><br><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;   #自定义防火墙日志存储位置</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>reg 一些有关于注册表的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;         #查看服务器127.0.0.1的1080端口的代理情况</span><br><span class="line"></span><br><span class="line">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal\Server\WinStations\RDP-Tcp&quot; &#x2F;V PortNumber    #查看远程连接端口。例如0xd3d，转化为10进制为3389</span><br><span class="line"></span><br><span class="line">wmic path win32_terminalservicesetting where (_CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1   #在windows server2003中开启3389端口</span><br><span class="line"></span><br><span class="line">wmic &#x2F;namespace: \\root\cimv2\terminalsercives path win32_terminalservicesetting where (_CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1   #在windows server2008中开启3389端口</span><br><span class="line"></span><br><span class="line">wmic &#x2F;namespace: \\root\cimv2\terminalsercives path win32_tsgeneralsetting where (TerminalName&#x3D;&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1    #在windows server2012中开启3389端口</span><br><span class="line"></span><br><span class="line">reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; &#x2F;V fSingleSessionPerUer &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f  </span><br></pre></td></tr></table></figure></li></ul><p>​         <em><strong>reg 命令详解使用reg /?。</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>liunx-sudo权限提升漏洞(CVE-2021-3156)复现</title>
      <link href="2021/03/12/linux%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E/"/>
      <url>2021/03/12/linux%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="liunx-sudo权限提升漏洞-CVE-2021-3156-复现"><a href="#liunx-sudo权限提升漏洞-CVE-2021-3156-复现" class="headerlink" title="liunx sudo权限提升漏洞(CVE-2021-3156)复现"></a>liunx sudo权限提升漏洞(CVE-2021-3156)复现</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><blockquote><p>​          1月26日，Sudo发布安全通告，修复了一个类Unix操作系统在命令参数中转义反斜杠时存在基于堆的缓冲区溢出漏洞。当sudo通过-s或-i命令行选项在shell模式下运行命令时，它将在命令参数中使用反斜杠转义特殊字符。但使用-s或-i标志运行sudoedit时，实际上并未进行转义，从而可能导致缓冲区溢出。只要存在sudoers文件（通常是/etc/sudoers），攻击者就可以使用本地普通用户利用sudo获得系统root权限。请受影响的用户尽快采取措施进行防护。</p></blockquote><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li><p>sudo 1.8.2-1.8.31p2 </p></li><li><p>sudo 1.9.0-1.9.5p1 </p></li><li><p>不受影响的版本 sudo=&gt;1.9.5p2</p></li></ul><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p><a href="https://haxx.in/CVE-2021-3156_nss_poc_ubuntu.tar.gz">POC地址</a><br>下载POC然后执行命令   </p><ul><li>cd CEV-2021-3156 </li><li> make </li><li>./sudo-hax-me-a-sandwich </li></ul><p>然后执行<code>whoami</code> 观察是否提权成功或执行<code>id</code><br>这个POC好像只对</p><ul><li><ol start="0"><li>Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31,<br>libc-2.31 </li></ol></li><li><ol><li>Debian 10.0 (Buster) - sudo 1.8.27, libc-2.28<br>这两个版本的可以使用，</li></ol></li></ul><h3 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h3><ul><li>  <img src="https://api2.mubu.com/v3/document_image/6212cca5-8352-4b21-8f7e-0ca046646b66-9600879.jpg"></li></ul><blockquote><p> 用户可以使用非root的账户登录系统，运行“ sudoedit -s / ”命令，<br>若返回如图以“ sudoedit：”开头的错误，则当前系统可能存在安全风险。<br>不受影响的系统将显示以“ usage：”开头的错误响应。 ​</p></blockquote><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><blockquote><p>下载最新版本的sudo <a href="https://www.sudo.ws/download.html">sudo官网</a><br>在linux服务器上使用wget下载下来 </p></blockquote><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget (https:&#x2F;&#x2F;www.sudo.ws&#x2F;dist&#x2F;sudo-1.9.5p2.tar.gz)</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>解压 <code>tar -zxvf sudo-1.9.5p2.tar.gz </code>   cd 到sudo-1.9.5文件下，然后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr --libexecdir&#x3D;&#x2F;usr&#x2F;lib --with-secure-path</span><br><span class="line">--with-all-insults --with-env-editor</span><br><span class="line">--docdir&#x3D;&#x2F;usr&#x2F;share&#x2F;doc&#x2F;sudo-1.9.5p2 --with-passprompt&#x3D;&quot;\[sudo\]</span><br><span class="line">password for %p: &quot; </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make make install &amp;&amp; ln -sfv</span><br><span class="line">libsudo_util.so.0.0.0 &#x2F;usr&#x2F;lib&#x2F;sudo&#x2F;libsudo_util.so.0</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo  -V</span><br></pre></td></tr></table></figure><p>查看版本发现安装成功。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>漏洞之越权</title>
      <link href="2020/03/12/%E6%BC%8F%E6%B4%9E%E4%B9%8B%E8%B6%8A%E6%9D%83/"/>
      <url>2020/03/12/%E6%BC%8F%E6%B4%9E%E4%B9%8B%E8%B6%8A%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞之越权"><a href="#漏洞之越权" class="headerlink" title="漏洞之越权"></a>漏洞之越权</h2><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote><p>​          如果使用A用户的权限去操作B用户的数据，A的权限小于B的权限，如果能够成功操作，则称之为越权操作。 越权漏洞形成的原因是后台使用了 不合理的权限校验规则导致的。</p></blockquote><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><blockquote><p>​        一般越权漏洞容易出现在权限页面（需要登录的页面）增、删、改、查的的地方，当用户对权限页面内的信息进行这些操作时，后台需要对 对当前用户的权限进行校验，看其是否具备操作的权限，从而给出响应，而如果校验的规则过于简单则容易出现越权漏洞。</p></blockquote><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><blockquote><p>因此，在在权限管理中应该遵守： 1.使用最小权限原则对用户进行赋权; 2.使用合理（严格）的权限校验规则; 3.使用后台登录态作为条件进行权限判断,别动不动就瞎用前端传进来的条件;</p></blockquote><h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><ul><li><p><strong>发生原因</strong></p><blockquote><p>水平越权的原因来自对于登录状态校检不够，只进行了登录状态的检验，并未进行登陆人身份的检测 </p></blockquote></li><li><p><strong>水平越权实例</strong></p><blockquote><p>​      在判断数据的用户时是通过从用户表单参数中获取userid来实现的，这里的话我们可以修改userid来实现</p><p>​         水平越权例如当A和B在同一网站登录时，A修改，查看。。信息，如果发送的是get请求。那么A把登陆的usename修改掉就会发生越权。post请求可以抓包。 下面演示一下。 </p></blockquote></li></ul><img src="https://img-blog.csdnimg.cn/20200323115854787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmhlemhhaQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <blockquote><p>我登上lili的账号</p></blockquote> <img src="https://img-blog.csdnimg.cn/20200323115944222.png" alt="在这里插入图片描述"> <blockquote><p>查看信息时把lili改为另一个用户lucy发现可以查看到lucy的信息。</p></blockquote><p> <img src="https://img-blog.csdnimg.cn/20200323120313334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmhlemhhaQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <img src="https://img-blog.csdnimg.cn/20200323120349534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmhlemhhaQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><blockquote><p>后台对于用户的登录身份未检测，只检测登陆状态。</p></blockquote><blockquote><p>关于水平越权后续会继续更新。推荐文章 <a href="https://www.cnblogs.com/xuxinstyle/p/9675541.html">token令牌</a> </p></blockquote><h2 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h2><blockquote><p>1.当你通过一些爬虫爬取网站时你可能会得到一些敏感网址，这些网址当不需要管理员的权限时就可以查看。等操作就发生的垂直越权。</p></blockquote><blockquote><p>延伸一点：使用爬虫你会得到网站的结构，或许运气好的话，能爬取到敏感文件。爬虫是在信息收集必备的手段。当你访问网站时访问你或许会得到一些东西。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
